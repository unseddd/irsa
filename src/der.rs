use alloc::vec::Vec;

use crate::{Error, Hash};

const MD2: [u8; 18] = [
    0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x02, 0x05, 0x00,
    0x04, 0x10,
];

const MD5: [u8; 18] = [
    0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x05, 0x05, 0x00,
    0x04, 0x10,
];

const SHA1: [u8; 15] = [
    0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14,
];

const SHA224: [u8; 19] = [
    0x30, 0x2d, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x04, 0x05,
    0x00, 0x04, 0x1c,
];

const SHA256: [u8; 19] = [
    0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05,
    0x00, 0x04, 0x20,
];

const SHA384: [u8; 19] = [
    0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05,
    0x00, 0x04, 0x30,
];

const SHA512: [u8; 19] = [
    0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05,
    0x00, 0x04, 0x40,
];

const SHA512_224: [u8; 19] = [
    0x30, 0x2d, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x05, 0x05,
    0x00, 0x04, 0x1c,
];

const SHA512_256: [u8; 19] = [
    0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x06, 0x05,
    0x00, 0x04, 0x20,
];

/// Get the DER encoding for a given hash function
pub fn encoding(hash: Hash) -> Result<Vec<u8>, Error> {
    let res = match hash {
        Hash::Md2 => MD2.to_vec(),
        Hash::Md5 => MD5.to_vec(),
        Hash::Sha1 => SHA1.to_vec(),
        Hash::Sha224 => SHA224.to_vec(),
        Hash::Sha256 => SHA256.to_vec(),
        Hash::Sha384 => SHA384.to_vec(),
        Hash::Sha512 => SHA512.to_vec(),
        Hash::Sha512_224 => SHA512_224.to_vec(),
        Hash::Sha512_256 => SHA512_256.to_vec(),
    };

    Ok(res)
}
